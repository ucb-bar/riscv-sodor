About The Sodor Processor Collection
====================================
[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/librecores/riscv-sodor?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)

Diagrams: [Sodor Github wiki](https://github.com/ucb-bar/riscv-sodor/wiki)

More documentation: [Librecores Sodor wiki](https://github.com/librecores/riscv-sodor/wiki)

Downstream development: [Librecores Sodor](https://github.com/librecores/riscv-sodor)


This repo has been put together to demonstrate a number of simple [RISC-V](http://riscv.org)
integer pipelines written in [Chisel](http://chisel.eecs.berkeley.edu):

* 1-stage (essentially an ISA simulator)
* 2-stage (demonstrates pipelining in Chisel)
* 3-stage (uses sequential memory; supports both Harvard and Princeton versions)
* 5-stage (can toggle between fully bypassed or fully interlocked)
* "bus"-based micro-coded implementation

All of the cores implement the RISC-V 32b integer base user-level ISA (RV32I)
version 2.2. None of the cores support virtual memory, and thus only implement
the Machine-level (M-mode) of the Privileged ISA v1.10 .

All processors talk to a simple scratchpad memory (asynchronous,
single-cycle), with no backing outer memory (the 3-stage is the exception
\- its scratchpad is synchronous). Programs are loaded in via a Debug Transport Module
 (DTM) described in [Debug Spec v0.13](https://static.dev.sifive.com/riscv-debug-spec-0.13.b4f1f43.pdf) port (while the core is kept in reset), effectively making the
scratchpads 3-port memories (instruction, data, debug).

Sodor is also ported to FPGA([PYNQ-Z1](http://store.digilentinc.com/pynq-z1-python-productivity-for-zynq/)) wherein 3stage core is used along with the uncore from Rocket-Chip 
making it capable to speak [tilelink](https://static.dev.sifive.com/docs/tilelink/tilelink-spec-1.7-draft.pdf) and AXI4(via tilelink adapter). It is able to execute and pass all riscv-tests and riscv-bmarks on FPGA. Currently there are no caches and DDR on FPGA is 
the only accessible storage. ELF's are loaded via [XSDB](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_3/SDK_Doc/concepts/sdk_c_xsd_over.htm), for more details check [README](https://github.com/librecores/riscv-sodor/blob/fpga/emulator/fpgazynq/README.md). Apart from emulating sodor on FPGA, the surrounding that 3stage faces on FPGA, can also be simulated in software [zynqsimtop](https://github.com/librecores/riscv-sodor/tree/fpga/emulator/zynqsimtop). For more details try microarchitecture diagrams in /doc 

This repository is set up to use the Verilog file generated by Chisel3/FIRRTL which is fed
to Verilator along with a test harness in C++ to generate and run the Sodor emulators.

This repo works great as an undergraduate lab (and has been used by Berkeley's
CS152 class for 3 semesters and counting). See doc/ for an example, as well as
for some processor diagrams which can be viewed using [draw.io](https://www.draw.io) using the following steps  draw.io -> File -> Import from -> URL then add this https://raw.githubusercontent.com/librecores/riscv-sodor/master/doc/1stage.xml. 

Getting the repo
================
```bash
git clone https://github.com/ucb-bar/riscv-sodor.git
cd riscv-sodor
git submodule update --init --recursive
```

Building the processor emulators
================================

Because this repository is designed to be used as RISC-V processor
examples written in [Chisel3](https://github.com/freechipsproject/chisel3/wiki) (and a regressive testsuite for Chisel updates),
no external [RISC-V tools](http://riscv.org) are used (with the exception of
the RISC-V [front-end server](https://github.com/codelec/riscv-fesvr) and
optionally, the [spike-dasm](https://github.com/riscv/riscv-isa-run) binary to
provide a disassembly of instructions in the generated *.out files).
The assumption is that [riscv-gnu-toolchain](https://github.com/riscv/riscv-gnu-toolchain) is not
available on the local system.  Thus, RISC-V unit tests and benchmarks were
compiled and committed to the sodor repository in the ./install directory (as are the .dump files).

Install verilator using any of the following possible ways
For Ubuntu 17.04 and above
```bash
sudo apt install pkg-config verilator
#optionally gtkwave to view waveform dumps
```

For Ubuntu 16.10 and lower
```bash 
sudo apt install pkg-config
wget http://mirrors.kernel.org/ubuntu/pool/universe/v/verilator/verilator_3.900-1_amd64.deb
sudo dpkg -i verilator_3.900-1_amd64.deb
```

If you don't have enough permissions to use apt on your machine
```bash
# make autoconf g++ flex bison should be available
wget https://www.veripool.org/ftp/verilator-3.906.tgz
tar -xzf verilator-3.906.tgz
cd verilator-3.906
unset VERILATOR_ROOT
./configure
make
export VERILATOR_ROOT=$PWD
export PATH=$PATH:$VERILATOR_ROOT/bin
```

Install the RISC-V front-end server to talk between the host and RISC-V target processors.
```bash
cd riscv-fesvr
mkdir build; cd build
../configure --prefix=/usr/local
make install 
```

Build the sodor emulators
```bash
make
# To run the all the stages with the tests available in ./install
# Compile tests using instructions given below
make run-emulator
# To install the executables on the local system
make install
# Clean all generated files
make clean
```
(Although you can set the prefix to any directory of your choice, they must be
the same directory for both riscv-fesvr and riscv-sodor).

Running the RISC-V tests
========================

    $ make run-emulator

(Optional) Running debug version to produce signal traces
---------------------------------------------------------
```bash
make run-emulator-debug
```
When run in debug mode, all processors will generate .vcd information (viewable
by your favorite waveform viewer). All processors can also spit out cycle-by-cycle 
log information.
Although already done for you by the build system, to generate .vcd files, see
 emulator/common/Makefile.include to add the "-v${vcdfilename}" flag to the
emulator-debug binary.

RISC-V fesvr allows you to use elf as input to sodor cores so no need to generate
the hex files

Have fun!

The riscv-test Collection
=========================

Sodor includes a submodule link to the "riscv-tests" repository. 

Building RISC-V Toolchain
--------------------------

If you would like to compile your own tests, you will need to build an
RISC-V compiler. Set $RISCV to where you would like to install RISC-V related
tools generally `/opt/riscv`, and make sure that $RISCV/bin is in your path.
```bash
git clone --recursive https://github.com/riscv/riscv-gnu-toolchain.git
cd riscv-gnu-toolchain
mkdir build; cd build
../configure --prefix=$RISCV --enable-multilib
make -j4
```
This will install a compiler named riscv64-unknown-elf-gcc

### Alternative 
Sifive also provides prebuilt toolchain found here [tools](https://www.sifive.com/products/tools/) which can be used to generate ELF's for Sodor

Compiling the tests
----------------------------
Append to line in [isa/Makefile:33](https://github.com/riscv/riscv-tests/blob/6f7ebb610d6bb8817a9592cc06a7d108381f1761/isa/Makefile#L33)  `-march=rv32i -mabi=ilp32`
```bash
    cd riscv-tests/isa
    make rv32ui
    make rv32mi
```
Sodor only supports the rv32ui-p (user-level) and rv32mi-p (machine-level) physical memory tests.

Append to line in [benchmarks/Makefile:40](https://github.com/riscv/riscv-tests/blob/6f7ebb610d6bb8817a9592cc06a7d108381f1761/benchmarks/Makefile#L40)  `-march=rv32i -mabi=ilp32`
```bash
    cd riscv-tests/benchmarks
    make #will fail at compiling mm which is not supported and not needed
    make dhrystone.riscv
```
After compiling the tests and benchmarks, for the tests edit line in [emulator/common/Makefile.include:138](https://github.com/librecores/riscv-sodor/blob/92663cc23f0d52d20e448802c4c5def8a717fa1c/emulator/common/Makefile.include#L138) to indicate the appropriate path to ELF's and similarly for benchmarks by editing [emulator/common/Makefile.include:191](https://github.com/librecores/riscv-sodor/blob/92663cc23f0d52d20e448802c4c5def8a717fa1c/emulator/common/Makefile.include#L191)

Running tests on the ISA simulator
----------------------------------

If you would like to run tests yourself, you can use the Spike ISA simulator
(found in riscv-tools on the riscv.org webpage). By default, Spike executes in
RV64G mode. To execute RV32I binaries, for example:

    spike --isa=RV32I rv32ui-p-simple
    spike --isa=RV32I dhrystone.riscv

The generated assembly code looks too complex!
----------------------------------------------

For Sodor, the assembly tests rely on macros that can be found in the
riscv-tests/env/p directory. You can simplify these macros as desired.


FAQ
===

*What is the goal of these cores?*

First and foremost, to provide a set of easy to understand cores that users can
easily modify and play with. Sodor is useful both as a quick introduction to
the [RISC-V ISA](http://riscv.org) and to the hardware construction language
[Chisel3](http://chisel.eecs.berkeley.edu).

*Are there any diagrams of these cores?*

Diagrams of some of the processors can be found either in the
[Sodor Github wiki](https://github.com/ucb-bar/riscv-sodor/wiki), in doc/,
or in doc/lab1.pdf.  A more comprehensive write-up on the micro-code implementation can
be found at the [CS152 website](http://inst.eecs.berkeley.edu/~cs152/sp12/handouts/microcode.pdf).


*How do I generate Verilog code for use on a FPGA?*

Chisel3/Firrtl outputs verilog by default which can be generated by
```bash
cd emulator/rv32_1stage
make generated-src/Top.v
```

*I want to help! Where do I go?*

You can participate in the Sodor conversation on [gitter](https://gitter.im/librecores/riscv-sodor). Downstream development is also taking place at [Librecores](https://github.com/librecores/riscv-sodor). Major milestones will be pulled back here. Check it out! We also accept pull requests here!

TODO
----

Here is an informal list of things that would be nice to get done. Feel free to
contribute!

* Reduce the port count on the scratchpad memory by having the Debug Module port
  share one of the cpu ports.
* Add support for the ma_addr, ma_fetch ISA tests. This requires detecting
  misaligned address exceptions.
* Greatly cleanup the common/csr.scala file, to make it clearer and more
  understandable.
* Refactor the stall, kill, fencei, and exception logic of the 5-stage to be
  more understandable.
